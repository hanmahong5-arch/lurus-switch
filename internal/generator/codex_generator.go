package generator

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"

	"github.com/BurntSushi/toml"

	"lurus-switch/internal/config"
)

// CodexGenerator generates Codex CLI configuration files
type CodexGenerator struct{}

// NewCodexGenerator creates a new Codex generator
func NewCodexGenerator() *CodexGenerator {
	return &CodexGenerator{}
}

// Generate creates the config.toml file for Codex CLI
func (g *CodexGenerator) Generate(cfg *config.CodexConfig, outputDir string) (string, error) {
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return "", fmt.Errorf("failed to create output directory: %w", err)
	}

	outputPath := filepath.Join(outputDir, "config.toml")

	content, err := g.GenerateString(cfg)
	if err != nil {
		return "", err
	}

	if err := os.WriteFile(outputPath, []byte(content), 0644); err != nil {
		return "", fmt.Errorf("failed to write config.toml: %w", err)
	}

	return outputPath, nil
}

// GenerateString generates the config.toml content as a string
func (g *CodexGenerator) GenerateString(cfg *config.CodexConfig) (string, error) {
	var buf bytes.Buffer

	// Write header comment
	buf.WriteString("# Codex CLI Configuration\n")
	buf.WriteString("# Generated by Lurus Switch\n\n")

	encoder := toml.NewEncoder(&buf)
	encoder.Indent = ""

	if err := encoder.Encode(cfg); err != nil {
		return "", fmt.Errorf("failed to encode config to TOML: %w", err)
	}

	return buf.String(), nil
}

// GenerateWithInstructions generates a config with custom instructions file
func (g *CodexGenerator) GenerateWithInstructions(cfg *config.CodexConfig, instructions string, outputDir string) ([]string, error) {
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return nil, fmt.Errorf("failed to create output directory: %w", err)
	}

	var files []string

	// Generate main config
	configPath, err := g.Generate(cfg, outputDir)
	if err != nil {
		return nil, err
	}
	files = append(files, configPath)

	// Generate instructions file if provided
	if instructions != "" {
		instructionsPath := filepath.Join(outputDir, "instructions.md")
		if err := os.WriteFile(instructionsPath, []byte(instructions), 0644); err != nil {
			return files, fmt.Errorf("failed to write instructions.md: %w", err)
		}
		files = append(files, instructionsPath)
	}

	return files, nil
}

// Validate validates the Codex configuration
func (g *CodexGenerator) Validate(cfg *config.CodexConfig) error {
	if cfg.Model == "" {
		return fmt.Errorf("model is required")
	}

	// Validate approval mode
	validModes := map[string]bool{"suggest": true, "auto-edit": true, "full-auto": true}
	if !validModes[cfg.ApprovalMode] {
		return fmt.Errorf("invalid approval mode: %s (must be 'suggest', 'auto-edit', or 'full-auto')", cfg.ApprovalMode)
	}

	// Validate provider type
	validProviders := map[string]bool{"openai": true, "azure": true, "openrouter": true, "custom": true}
	if !validProviders[cfg.Provider.Type] {
		return fmt.Errorf("invalid provider type: %s", cfg.Provider.Type)
	}

	// Azure requires deployment name
	if cfg.Provider.Type == "azure" && cfg.Provider.AzureDeployment == "" {
		return fmt.Errorf("azure_deployment is required for Azure provider")
	}

	// Validate network access
	validNetworkAccess := map[string]bool{"off": true, "local": true, "full": true}
	if !validNetworkAccess[cfg.Security.NetworkAccess] {
		return fmt.Errorf("invalid network access: %s (must be 'off', 'local', or 'full')", cfg.Security.NetworkAccess)
	}

	return nil
}
